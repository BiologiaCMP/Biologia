Entendido. Aquí tienes el código completo del juego "Jumpy Journey" empaquetado en un **único archivo HTML**. Solo tienes que copiar y pegar todo este contenido en un archivo llamado `index.html` y abrirlo con tu navegador.

-----

```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jumpy Journey</title>
    <style>
        /* Estilos del Juego (CSS Integrado) */
        body {
            font-family: 'Press Start 2P', cursive; /* Ideal para juegos retro */
            /* Importa fuente si no está localmente. Para fines de este archivo único, la eliminamos si no está instalada. */
            /* Si quieres la fuente, agrega esta línea después de la font-family: */
            /* @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap'); */

            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #2c3e50; /* Un color oscuro y agradable */
            color: #ecf0f1; /* Color de texto claro */
            margin: 0;
            overflow: hidden; /* Evita barras de desplazamiento */
        }

        #game-container {
            background-color: #34495e; /* Fondo del contenedor del juego */
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            text-align: center;
        }

        h1 {
            color: #f1c40f; /* Color llamativo para el título */
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }

        canvas {
            border: 3px solid #f1c40f; /* Borde del canvas */
            background-color: #7fd4e7; /* Fondo del cielo */
            display: block; /* Elimina espacios extra debajo del canvas */
            margin: 0 auto;
        }

        #game-info {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 30px; /* Espacio entre puntos y vidas */
            font-size: 1.1em;
            color: #bdc3c7;
        }

        #game-over-screen {
            position: fixed; /* Usar fixed para que cubra toda la ventana */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #ecf0f1;
            text-align: center;
            font-size: 1.5em;
            z-index: 100; /* Asegura que esté por encima de todo */
        }

        #game-over-screen h2 {
            color: #e74c3c; /* Rojo para el título de Game Over */
            margin-bottom: 20px;
        }

        #restart-button {
            background-color: #27ae60; /* Verde para el botón */
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 20px;
            transition: background-color 0.3s ease;
        }

        #restart-button:hover {
            background-color: #2ecc71;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>Jumpy Journey</h1>
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div id="game-info">
            <p>Puntos: <span id="score">0</span></p>
            <p>Vidas: <span id="lives">3</span></p>
        </div>
        <div id="game-over-screen" class="hidden">
            <h2>¡Juego Terminado!</h2>
            <p>Puntuación Final: <span id="final-score">0</span></p>
            <button id="restart-button">Jugar de Nuevo</button>
        </div>
    </div>

    <script>
        // Lógica del Juego (JavaScript Integrado)
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreDisplay = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');

        // --- Variables del Juego ---
        let score = 0;
        let lives = 3;
        let gameRunning = true;
        let level = 0; // Empieza en el nivel 0 (primer elemento del array levels)

        const GRAVITY = 0.5;
        const GROUND_LEVEL = canvas.height - 40; // Donde el suelo empieza
        const TILE_SIZE = 40; // Tamaño base para elementos (ej. bloques, personajes)

        // --- Jugador ---
        const player = {
            x: 50,
            y: GROUND_LEVEL - TILE_SIZE,
            width: TILE_SIZE,
            height: TILE_SIZE,
            color: 'red',
            speed: 5,
            velocityY: 0,
            isJumping: false,
            onGround: true,
            invincible: false, // Para después de ser golpeado
            invincibilityTimer: 0,
            maxInvincibilityTime: 120 // Cuadros (2 segundos a 60 FPS)
        };

        // --- Array para Teclas Presionadas ---
        const keys = {
            right: false,
            left: false,
            space: false
        };

        // --- Niveles (Definición de plataformas, enemigos, etc.) ---
        const levels = [
            // Nivel 0 (Nivel 1 del juego)
            {
                platforms: [
                    { x: 0, y: GROUND_LEVEL, width: canvas.width, height: TILE_SIZE, color: 'green' }, // Suelo principal
                    { x: 200, y: GROUND_LEVEL - TILE_SIZE * 2, width: TILE_SIZE * 3, height: TILE_SIZE, color: 'brown' },
                    { x: 500, y: GROUND_LEVEL - TILE_SIZE * 3, width: TILE_SIZE * 2, height: TILE_SIZE, color: 'brown' }
                ],
                enemies: [
                    { x: 300, y: GROUND_LEVEL - TILE_SIZE, width: TILE_SIZE, height: TILE_SIZE, color: 'purple', speed: 2, type: 'goomber', dir: 1 },
                    { x: 600, y: GROUND_LEVEL - TILE_SIZE, width: TILE_SIZE, height: TILE_SIZE, color: 'purple', speed: 2, type: 'goomber', dir: -1 }
                ],
                obstacles: [
                    { x: 400, y: GROUND_LEVEL - 20, width: TILE_SIZE, height: 20, color: 'gray', type: 'spike' }
                ],
                powerUps: [
                    { x: 100, y: GROUND_LEVEL - TILE_SIZE * 2, width: 20, height: 20, color: 'yellow', type: 'score' },
                    { x: 550, y: GROUND_LEVEL - TILE_SIZE * 4, width: 20, height: 20, color: 'blue', type: 'extraLife' }
                ],
                exit: { x: canvas.width - TILE_SIZE * 2, y: GROUND_LEVEL - TILE_SIZE * 2, width: TILE_SIZE, height: TILE_SIZE, color: 'gold' }
            },
            // Nivel 1 (Nivel 2 del juego)
            {
                platforms: [
                    { x: 0, y: GROUND_LEVEL, width: canvas.width, height: TILE_SIZE, color: 'darkgreen' },
                    { x: 100, y: GROUND_LEVEL - TILE_SIZE * 2, width: TILE_SIZE * 2, height: TILE_SIZE, color: 'darkbrown' },
                    { x: 300, y: GROUND_LEVEL - TILE_SIZE * 4, width: TILE_SIZE * 3, height: TILE_SIZE, color: 'darkbrown' },
                    { x: 600, y: GROUND_LEVEL - TILE_SIZE * 2, width: TILE_SIZE * 2, height: TILE_SIZE, color: 'darkbrown' }
                ],
                enemies: [
                    { x: 150, y: GROUND_LEVEL - TILE_SIZE * 3, width: TILE_SIZE, height: TILE_SIZE, color: 'darkpurple', speed: 3, type: 'goomber', dir: 1 },
                    { x: 400, y: GROUND_LEVEL - TILE_SIZE * 5, width: TILE_SIZE, height: TILE_SIZE, color: 'orange', speed: 2, type: 'spiker' } // Nuevo enemigo
                ],
                obstacles: [
                    { x: 250, y: GROUND_LEVEL - 20, width: TILE_SIZE * 2, height: 20, color: 'darkgray', type: 'spike' },
                    { x: 550, y: GROUND_LEVEL - 20, width: TILE_SIZE * 1.5, height: 20, color: 'darkgray', type: 'spike' }
                ],
                powerUps: [
                    { x: 350, y: GROUND_LEVEL - TILE_SIZE * 5, width: 20, height: 20, color: 'yellow', type: 'score' }
                ],
                exit: { x: canvas.width - TILE_SIZE * 2, y: GROUND_LEVEL - TILE_SIZE * 2, width: TILE_SIZE, height: TILE_SIZE, color: 'gold' }
            }
            // Puedes agregar más niveles aquí siguiendo el mismo formato
        ];

        let currentLevelData; // Se cargará al inicio de cada nivel

        // --- Inicializar Nivel ---
        function loadLevel(levelNum) {
            if (levelNum >= levels.length) {
                // Has completado todos los niveles
                console.log("¡Felicidades, has completado el juego!");
                showGameOver(true); // Puedes pasar un argumento para "victoria"
                return;
            }
            currentLevelData = JSON.parse(JSON.stringify(levels[levelNum])); // Copia profunda para no modificar el original
            player.x = 50;
            player.y = GROUND_LEVEL - TILE_SIZE;
            player.velocityY = 0;
            player.isJumping = false;
            player.onGround = true;
            player.invincible = false;
            player.invincibilityTimer = 0;
        }

        // --- Bucle Principal del Juego ---
        function gameLoop() {
            if (!gameRunning) return;

            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- Actualizar Estado del Juego ---
        function update() {
            // 1. Movimiento del Jugador
            if (keys.right) player.x += player.speed;
            if (keys.left) player.x -= player.speed;

            // Limitar movimiento dentro del canvas
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

            // 2. Gravedad
            player.y += player.velocityY;
            player.velocityY += GRAVITY;

            // 3. Saltar
            if (keys.space && player.onGround) {
                player.velocityY = -10; // Fuerza de salto
                player.isJumping = true;
                player.onGround = false;
            }

            // 4. Colisiones con Plataformas
            player.onGround = false; // Asumir que no está en el suelo hasta que haya colisión
            currentLevelData.platforms.forEach(platform => {
                if (checkCollision(player, platform)) {
                    // Si el jugador cae sobre la plataforma
                    if (player.velocityY > 0 && player.y + player.height - player.velocityY <= platform.y) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                        player.isJumping = false;
                    }
                    // Si el jugador golpea la plataforma desde abajo (opcional, para romper bloques)
                    else if (player.velocityY < 0 && player.y >= platform.y + platform.height) {
                        player.velocityY = 0; // Detiene el salto ascendente
                    }
                }
            });

            // Asegurarse de que el jugador no caiga por debajo del suelo
            if (player.y + player.height > GROUND_LEVEL) {
                player.y = GROUND_LEVEL - player.height;
                player.velocityY = 0;
                player.onGround = true;
                player.isJumping = false;
            }

            // 5. Actualizar Enemigos
            currentLevelData.enemies.forEach(enemy => {
                if (enemy.type === 'goomber') {
                    enemy.x += enemy.speed * enemy.dir;
                    // Detección de borde para que los Goomber giren
                    // Simplemente rebotan si llegan al borde del canvas por ahora
                    if (enemy.x <= 0 || enemy.x + enemy.width >= canvas.width) {
                        enemy.dir *= -1; // Cambiar dirección
                    }
                    // Simular caída sobre plataformas para enemigos
                    let enemyOnPlatform = false;
                    currentLevelData.platforms.forEach(platform => {
                        // Chequear colisión con el punto bajo del enemigo para saber si está sobre una plataforma
                        if (checkCollision({ x: enemy.x, y: enemy.y + enemy.height + 1, width: enemy.width, height: 1 }, platform)) {
                            enemyOnPlatform = true;
                            // Alinear el enemigo a la plataforma
                            enemy.y = platform.y - enemy.height;
                        }
                    });
                    // Si no está en una plataforma o en el suelo principal, aplicar gravedad
                    if (!enemyOnPlatform && enemy.y + enemy.height < GROUND_LEVEL) {
                         enemy.y += GRAVITY * 2; // Los enemigos también caen
                    } else if (enemy.y + enemy.height > GROUND_LEVEL) {
                        enemy.y = GROUND_LEVEL - enemy.height; // Alinear al suelo principal
                    }
                }
                // Si quieres agregar enemigos de tipo 'spiker' que no se mueven, no necesitan esta lógica de movimiento.
            });

            // 6. Detección de Colisión Jugador-Enemigo
            if (!player.invincible) {
                currentLevelData.enemies.forEach((enemy, index) => {
                    if (checkCollision(player, enemy)) {
                        if (player.velocityY > 0 && player.y + player.height - player.velocityY <= enemy.y && enemy.type !== 'spiker') {
                            // Jugador salta sobre el enemigo (aplastar)
                            updateScore(100);
                            // Eliminar enemigo
                            currentLevelData.enemies.splice(index, 1);
                            player.velocityY = -7; // Pequeño rebote al aplastar
                            player.isJumping = true; // Forzar el salto para evitar doble aplastamiento
                        } else {
                            // Jugador es golpeado por el enemigo (excepto si es por arriba y lo aplasta)
                            takeDamage();
                        }
                    }
                });
            } else {
                player.invincibilityTimer--;
                if (player.invincibilityTimer <= 0) {
                    player.invincible = false;
                }
            }


            // 7. Colisiones con Obstáculos
            currentLevelData.obstacles.forEach(obstacle => {
                if (checkCollision(player, obstacle)) {
                    if (obstacle.type === 'spike' && !player.invincible) {
                        takeDamage();
                    }
                }
            });

            // 8. Colisiones con Power-ups
            currentLevelData.powerUps.forEach((powerUp, index) => {
                if (checkCollision(player, powerUp)) {
                    if (powerUp.type === 'score') {
                        updateScore(50);
                    } else if (powerUp.type === 'extraLife') {
                        updateLives(1);
                    }
                    currentLevelData.powerUps.splice(index, 1); // Eliminar power-up
                }
            });

            // 9. Colisión con la Salida
            if (checkCollision(player, currentLevelData.exit)) {
                level++;
                updateScore(500); // Bonificación por nivel
                loadLevel(level); // Intentar cargar el siguiente nivel
                if (gameRunning) { // Asegúrate de que el juego no haya terminado por completar todos los niveles
                    console.log(`¡Nivel ${level + 1} Completado!`); // Mostrar número de nivel correcto
                }
            }
        }

        // --- Dibujar Elementos del Juego ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpiar el canvas

            // Dibujar suelo y plataformas
            currentLevelData.platforms.forEach(platform => {
                ctx.fillStyle = platform.color;
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            });

            // Dibujar Jugador
            ctx.fillStyle = player.invincible ? 'rgba(255, 0, 0, 0.5)' : player.color; // Color intermitente si es invencible
            ctx.fillRect(player.x, player.y, player.width, player.height);

            // Dibujar Enemigos
            currentLevelData.enemies.forEach(enemy => {
                ctx.fillStyle = enemy.color;
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
            });

            // Dibujar Obstáculos
            currentLevelData.obstacles.forEach(obstacle => {
                ctx.fillStyle = obstacle.color;
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            });

            // Dibujar Power-ups
            currentLevelData.powerUps.forEach(powerUp => {
                ctx.fillStyle = powerUp.color;
                ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
            });

            // Dibujar Salida
            ctx.fillStyle = currentLevelData.exit.color;
            ctx.fillRect(currentLevelData.exit.x, currentLevelData.exit.y, currentLevelData.exit.width, currentLevelData.exit.height);
        }

        // --- Funciones Auxiliares ---

        // Función de detección de colisiones AABB (Axis-Aligned Bounding Box)
        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.height > obj2.y;
        }

        function updateScore(points) {
            score += points;
            scoreDisplay.textContent = score;
        }

        function updateLives(change) {
            lives += change;
            livesDisplay.textContent = lives;
            if (lives <= 0) {
                gameOver();
            }
        }

        function takeDamage() {
            player.invincible = true;
            player.invincibilityTimer = player.maxInvincibilityTime;
            updateLives(-1);
            // Puedes agregar sonido o efecto visual aquí
        }

        function gameOver() {
            gameRunning = false;
            finalScoreDisplay.textContent = score;
            gameOverScreen.classList.remove('hidden');
        }

        function showGameOver(won = false) {
             gameRunning = false;
             finalScoreDisplay.textContent = score;
             gameOverScreen.querySelector('h2').textContent = won ? '¡Juego Completado!' : '¡Juego Terminado!';
             gameOverScreen.classList.remove('hidden');
        }

        function restartGame() {
            score = 0;
            lives = 3;
            level = 0; // Reiniciar al primer nivel
            updateScore(0); // Para actualizar el display
            updateLives(0); // Para actualizar el display
            gameOverScreen.classList.add('hidden');
            gameRunning = true;
            loadLevel(level);
            gameLoop();
        }

        // --- Event Listeners para el Teclado ---
        document.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                keys.right = true;
            } else if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                keys.left = true;
            } else if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
                keys.space = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                keys.right = false;
            } else if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                keys.left = false;
            } else if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
                keys.space = false;
            }
        });

        restartButton.addEventListener('click', restartGame);

        // --- Iniciar el Juego ---
        loadLevel(level);
        gameLoop();
    </script>
</body>
</html>
```
